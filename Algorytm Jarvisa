'''
def det(p, q, r):         
	xp, yp = p
	xq, yq = q
	xr, yr = r
	return xr*(yp - yq) - xq*(yp - yr) + xp*(yq - yr)

def alfa(p):
	xp, yp = p
	dp = abs(xp) + abs(yp)
	if yp >= 0 and xp >= 0:
		return yp / dp
	if xp <= 0 and yp >= 0:
		return 2 - (yp / dp)
	if xp <= 0 and yp <= 0:
		return 2 + (abs(yp) / dp)
	if xp >= 0 and yp <= 0:
		return 4 - (abs(yp) / dp)

punkty = [(-2, -4), (-4, -2), (-3, 1), (-3, 4), (4, 5), (2, 3), (1, 1), (0, 0), (2, -2), (2, -4), (1, -1)]

def yx(p):
	return p[1], p[0]


dane = sorted(punkty, key = yx)                #algorytm grahama
print(dane)
p0 = dane.pop(0)
print(p0)
nowe = [(p[0] - p0[0], p[1] - p0[1]) for p in dane]
print(nowe)
nowe = sorted(nowe, key = alfa)
print(nowe)
stos = [(0, 0), nowe[0], nowe[1]]
print(stos)

for i in range(2, len(nowe)):
	while det(stos[-2], stos[-1], nowe[i]) <= 0:
		stos.pop()
	stos.append(nowe[i])

print(stos)
print("skonczylem essa")
wynik = [(p[0] + p0[0], p[1] + p0[1]) for p in stos]
print(wynik)
'''

def Jarvis(P):             #Algorytm Jarvisa
	if len(P) < 3:
		return P
	H = []
	dane = sorted(punkty, key = yx)
	p0 = dane.pop(0)
	p = p0
	
	while True:
		H.append(p)
		if P[0] != p:
			q = P[0]
		else:
			q = P[-1]
		
		for r in P:
			if r != p:
				if det(p, q, r) > 0:
					q = r
				elif det(p, q, r) == 0:
					if (p[0] - r[0])**2 + (p[1] - r[1])**2  > (p[0] - q[0])**2 + (p[1] - q[1])**2:
						q = r
		p = q
		if p == p0:
			break
	return H
print(Jarvis(punkty))
